# Java 并发

## 线程安全

多个线程同时访问时，其都能表现出正确的行为。无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织，调用端代码都无需额外的同步或其他协调动作。

1. 不可变
2. 线程隔离
   1. 栈封闭（栈上元素）
   2. ThreadLocal
3. 加锁
   1. 乐观锁 CAS
   2. 悲观锁

## 偏向锁

1. Thread1 拿到偏向锁后，偏向锁始终指向Thread1 (即使Thread1消亡)
2. 若某个类下的对象偏向锁次数 > 20 如果后续产生竞争会进行批量重偏向，即若再产生竞争直接偏向竞争的线程。（前20次是无所可偏向->偏向->轻量锁->无锁不可偏向）
3. 若某个类下的对象偏向锁次数 > 40 在类上关闭偏向标记，后续不可偏向。批量撤销。

## 栈帧结构

1. 局部变量表
2. 操作数栈
3. 动态链接
4. 返回地址
5. 其他信息

## volatile

### 可见性

使用内存屏障控制工作内存的数据即时刷入主内存。（MESI协议）

### 有序性

使用内存屏障防止指令重排

1. 当第二个操作是 volatile写 的时候，保证不会重排序
2. 当第一个操作是 volatile读 的时候，保证不会重排序
3. 当第一个操作是 volatile写 的时候，第二个操作是 volatile读 的时候，保证不会重排序

## final

final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。

final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。
